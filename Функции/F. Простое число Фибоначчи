## В решении этой задачи нужно использовать функцию isPrime, которая была написана в задаче "Простые числа".
Последовательность чисел Фибоначчи задается следующим образом: F(1)=1,F(2)=1,F(n)=F(n−1)+F(n−2)F(1)=1,F(2)=1,F(n)=F(n−1)+F(n−2)
Напишите функцию uint64_t getPrimeFibNumber(uint32_t idx), которая вернет элемент под номером idx из последовательности Фибоначчи, если это простое число, иначе — 0. В функции getPrimeFibNumber необходимо использовать функцию isPrime.
Например,
    getPrimeFibNumber(5) == 5 (так как 5 — простое число)
    getPrimeFibNumber(6) == 0 (так как 8 — составное число)
В файле решения должны быть ТОЛЬКО требуемые функции и необходимые хэдеры (#include)
Функции могут вызываться множество раз, необходимо реализовать оптимальный алгоритм.

#include <cstdint>

bool isPrime(uint64_t n) {
    if (n < 2) {
        return false;
    }
    if (n == 2 || n == 3) {
        return true;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }

    uint64_t i = 5;
    while (i * i <= n) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
        i += 6;
    }
    return true;
}

uint64_t getPrimeFibNumber(uint32_t idx) {
    if (idx == 1 || idx == 2) {
        return 0;
    }
    uint64_t a = 1, b = 1;
    for (uint32_t i = 3; i <= idx; ++i) {
        uint64_t next = a + b;
        a = b;
        b = next;
    }
    if (isPrime(b)) {
        return b;
    }
    return 0;
}
